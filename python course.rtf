{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}{\f2\fnil Calibri;}{\f3\fnil\fcharset0 Cambria Math;}{\f4\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.18362}{\*\mmathPr\mmathFont1\mwrapIndent1440 }\viewkind4\uc1 
\pard\ri-1710\sa200\sl276\slmult1\tx10260\tx10350\f0\fs22\lang9  What makes a language?\par
We can say that each language (machine or natural, it doesn't matter) consists of the following elements:\par
\par
AN ALPHABET\par
a set of symbols used to build words of a certain language (e.g., the Latin alphabet for English, the Cyrillic alphabet for Russian, Kanji for Japanese, and so on)\par
\par
A LEXIS\par
(aka a dictionary) a set of words the language offers its users (e.g., the word "computer" comes from the English language dictionary, while "cmoptrue" doesn't; the word "chat" is present both in English and French dictionaries, but their meanings are different)\par
\par
A SYNTAX\par
a set of rules (formal or informal, written or felt intuitively) used to determine if a certain string of words forms a valid sentence (e.g., "I am a python" is a syntactically correct phrase, while "I a python am" isn't)\par
\par
SEMANTICS\par
a set of rules determining if a certain phrase makes sense (e.g., "I ate a doughnut" makes sense, but "A doughnut ate me" doesn't)\par
\par
The IL is, in fact, the alphabet of a machine language. This is the simplest and most primary set of symbols we can use to give commands to a computer. It's the computer's mother tongue.\par
\par
\par
nfortunately, this tongue is a far cry from a human mother tongue. We all (both computers and humans) need something else, a common language for computers and humans, or a bridge between the two different worlds.\par
\par
We need a language in which humans can write their programs and a language that computers may use to execute the programs, one that is far more complex than machine language and yet far simpler than natural language.\par
\par
Such languages are often called high-level programming languages. They are at least somewhat similar to natural ones in that they use symbols, words and conventions readable to humans. These languages enable humans to express commands to computers that are much more complex than those offered by ILs.\par
\par
A program written in a high-level programming language is called a source code (in contrast to the machine code executed by computers). Similarly, the file containing the source code is called the source file.\par
Compilation vs. interpretation\par
Computer programming is the act of composing the selected programming language's elements in the order that will cause the desired effect. The effect could be different in every specific case - it's up to the programmer's imagination, knowledge and experience.\par
\par
Of course, such a composition has to be correct in many senses:\par
\par
alphabetically - a program needs to be written in a recognizable script, such as Roman, Cyrillic, etc.\par
lexically - each programming language has its dictionary and you need to master it; thankfully, it's much simpler and smaller than the dictionary of any natural language;\par
syntactically - each language has its rules and they must be obeyed;\par
semantically - the program has to make sense.\par
Unfortunately, a programmer can also make mistakes with each of the above four senses. Each of them can cause the program to become completely useless.\par
\par
Let's assume that you've successfully written a program. How do we persuade the computer to execute it? You have to render your program into machine language. Luckily, the translation can be done by a computer itself, making the whole process fast and efficient.\par
\par
\par
There are two different ways of transforming a program from a high-level programming language into machine language:\par
\par
COMPILATION - the source program is translated once (however, this act must be repeated each time you modify the source code) by getting a file (e.g., an .exe file if the code is intended to be run under MS Windows) containing the machine code; now you can distribute the file worldwide; the program that performs this translation is called a compiler or translator;\par
\par
INTERPRETATION - you (or any user of the code) can translate the source program each time it has to be run; the program performing this kind of transformation is called an interpreter, as it interprets the code every time it is intended to be executed; it also means that you cannot just distribute the source code as-is, because the end-user also needs the interpreter to execute it.\par
\par
Due to some very fundamental reasons, a particular high-level programming language is designed to fall into one of these two categories.\par
\par
There are very few languages that can be both compiled and interpreted. Usually, a programming language is projected with this factor in its constructors' minds - will it be compiled or interpreted?\par
\par
\par
What does the interpreter actually do?\par
Let's assume once more that you have written a program. Now, it exists as a computer file: a computer program is actually a piece of text, so the source code is usually placed in text files. Note: it has to be pure text, without any decorations like different fonts, colors, embedded images or other media. Now you have to invoke the interpreter and let it read your source file.\par
\par
The interpreter reads the source code in a way that is common in Western culture: from top to bottom and from left to right. There are some exceptions - they'll be covered later in the course.\par
\par
First of all, the interpreter checks if all subsequent lines are correct (using the four aspects covered earlier).\par
\par
If the compiler finds an error, it finishes its work immediately. The only result in this case is an error message. The interpreter will inform you where the error is located and what caused it. However, these messages may be misleading, as the interpreter isn't able to follow your exact intentions, and may detect errors at some distance from their real causes.\par
\par
For example, if you try to use an entity of an unknown name, it will cause an error, but the error will be discovered in the place where it tries to use the entity, not where the new entity's name was introduced.\par
\par
In other words, the actual reason is usually located a little earlier in the code, e.g., in the place where you had to inform the interpreter that you were going to use the entity of the name.\par
If the line looks good, the interpreter tries to execute it (note: each line is usually executed separately, so the trio "read-check-execute" can be repeated many times - more times than the actual number of lines in the source file, as some parts of the code may be executed more than once).\par
\par
It is also possible that a significant part of the code may be executed successfully before the interpreter finds an error. This is normal behavior in this execution model.\par
\par
You may ask now: which is better? The "compiling" model or the "interpreting" model? There is no obvious answer. If there had been, one of these models would have ceased to exist a long time ago. Both of them have their advantages and their disadvantages.\par
At the height of its success, the Monty Python team were performing their sketches to live audiences across the world, including at the Hollywood Bowl.\par
\par
Since Monty Python is considered one of the two fundamental nutrients to a programmer (the other being pizza), Python's creator named the language in honor of the TV show.\par
\par
Who created Python?\par
One of the amazing features of Python is the fact that it is actually one person's work. Usually, new programming languages are developed and published by large companies employing lots of professionals, and due to copyright rules, it is very hard to name any of the people involved in the project. Python is an exception.\par
\par
There are not many languages whose authors are known by name. Python was created by Guido van Rossum, born in 1956 in Haarlem, the Netherlands. Of course, Guido van Rossum did not develop and evolve all the Python components himself.\par
\par
The speed with which Python has spread around the world is a result of the continuous work of thousands (very often anonymous) programmers, testers, users (many of them aren't IT specialists) and enthusiasts, but it must be said that the very first idea (the seed from which Python sprouted) came to one head - Guido's.\par
How to spoil and fix your code\par
You may have noticed that the error message generated for the previous error is quite different from the first one.\par
\par
Python 3.7.0 IDLE - Console error message after running a program with removed letter t from the print() function\par
\par
This is because the nature of the error is different and the error is discovered at a different stage of interpretation.\par
\par
\par
\par
The editor window will not provide any useful information regarding the error, but the console windows might.\par
\par
The message (in red) shows (in the subsequent lines):\par
\par
the traceback (which is the path that the code traverses through different parts of the program - you can ignore it for now, as it is empty in such a simple code);\par
the location of the error (the name of the file containing the error, line number and module name); note: the number may be misleading, as Python usually shows the place where it first notices the effects of the error, not necessarily the error itself;\par
the content of the erroneous line; note: IDLE\rquote s editor window doesn\rquote t show line numbers, but it displays the current cursor location at the bottom-right corner; use it to locate the erroneous line in a long source code;\par
the name of the error and a short explanation.\par
\par
Experiment with creating new files and running your code. Try to output a different message to the screen, e.g., roar!, meow, or even maybe an oink!. Try to spoil and fix your code - see what happens.\par
\par
\par
Sandbox\par
This course does not require you to install any software applications to test your code and do the exercises.\par
\par
To test or experiment with your code, you can use a dedicated, interactive on-line programming environment.\par
\par
Sandbox allows Python code to be run in an Internet browser.\par
\par
\par
Sandbox concept\par
\par
It is a tool integrated within the course, which can be used as a browser-based Python sandbox that allows you to test code discussed throughout the course, as well as an interpreter that enables you to launch, perform and test the lab exercises specifically designed for this course.\par
\par
The Sandbox interface consists of three main parts:\par
\par
the Editor window, which lets you type in your code,\par
the Console window, which lets you see the output of your programs,\par
a tool named the Action Buttons bar, which lets you run your code, refresh the editor window, download your program as a .py file, upload a .py file that will be displayed in the editor, report a bug (in case you spot anything wrong, do let us know about it!)\par
and the Settings button, which lets you adjust display settings and switch between Python/C/C++ environments.\par
\par
Now copy the following code:\par
\par
print("Hello!")\par
print("Welcome to Python Essentials!")\par
print("THIS IS SANDBOX MODE.")\par
\par
...then click the Sandbox button to enter Sandbox Mode, paste the code in the editor window, and click the Run button to see what happens.\par
\par
To get back to our course, click Back to course in the top right-hand corner of the Sandbox interface.\par
The print() function\par
The function name (print in this case) along with the parentheses and argument(s), forms the function invocation.\par
\par
We'll discuss this in more depth soon, but we should just shed a little light on it right now.\par
\par
print("Hello, World!")\par
\par
\par
What happens when Python encounters an invocation like this one below?\par
\par
function_name(argument)\par
\par
\par
Let's see:\par
\par
First, Python checks if the name specified is legal (it browses its internal data in order to find an existing function of the name; if this search fails, Python aborts the code);\par
second, Python checks if the function's requirements for the number of arguments allows you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, any invocation delivering only one argument will be considered erroneous, and will abort the code's execution);\par
third, Python leaves your code for a moment and jumps into the function you want to invoke; of course, it takes your argument(s) too and passes it/them to the function;\par
fourth, the function executes its code, causes the desired effect (if any), evaluates the desired result(s) (if any) and finishes its task;\par
finally, Python returns to your code (to the place just after the invocation) and resumes its execution.\par
\par
\par
 What is the effect the print() function causes?\par
\par
The effect is very useful and very spectacular. The function:\par
\par
takes its arguments (it may accept more than one argument and may also accept less than one argument)\par
converts them into human-readable form if needed (as you may suspect, strings don't require this action, as the string is already readable)\par
and sends the resulting data to the output device (usually the console); in other words, anything you put into the print() function will appear on your screen.\par
No wonder then, that from now on, you'll utilize print() very intensively to see the results of your operations and evaluations.\par
\par
\par
2. What arguments does print() expect?\par
\par
Any. We'll show you soon that print() is able to operate with virtually all types of data offered by Python. Strings, numbers, characters, logical values, objects - any of these may be successfully passed to print().\par
\par
\par
3. What value does the print() function evaluate?\par
\par
None. Its effect is enough - print() does not evaluate anything\par
\par
\par
\par
he print() function - the keyword arguments\par
Python offers another mechanism for the passing of arguments, which can be helpful when you want to convince the print() function to change its behavior a bit.\par
\par
We aren't going to explain it in depth right now. We plan to do this when we talk about functions. For now, we simply want to show you how it works. Feel free to use it in your own programs.\par
\par
The mechanism is called keyword arguments. The name stems from the fact that the meaning of these arguments is taken not from its location (position) but from the special word (keyword) used to identify them.\par
\par
The print() function has two keyword arguments that you can use for your purposes. The first of them is named end.\par
\par
In the editor window you can see a very simple example of using a keyword argument.\par
\par
In order to use it, it is necessary to know some rules:\par
\par
a keyword argument consists of three elements: a keyword identifying the argument (end here); an equal sign (=); and a value assigned to that argument;\par
any keyword arguments have to be put after the last positional argument (this is very important)\par
\par
In our example, we have made use of the end keyword argument, and set it to a string containing one space.\par
\par
Run the code to see how it works.\par
\par
The console should now be showing the following text:\par
\par
My name is Python. Monty Python.\par
output\par
\par
As you can see, the end keyword argument determines the characters the print() function sends to the output once it reaches the end of its positional arguments.\par
\par
The default behavior reflects the situation where the end keyword argument is implicitly used in the following way: end="\\n".\par
The print() function - the keyword arguments\par
And now it's time to try something more difficult.\par
\par
If you look carefully, you'll see that we've used the end argument, but the string assigned to it is empty (it contains no characters at all).\par
\par
What will happen now? Run the program in the editor to find out.\par
\par
As the end argument has been set to nothing, the print() function outputs nothing too, once its positional arguments have been exhausted.\par
\par
The console should now be showing the following text:\par
\par
My name is Monty Python.\par
output\par
\par
Note: no newlines have been sent to the output.\par
\par
The string assigned to the end keyword argument can be of any length. Experiment with it if you want.\par
\par
\par
he print() function - the keyword arguments\par
We've said previously that the print() function separates its outputted arguments with spaces. This behavior can be changed, too.\par
\par
The keyword argument that can do this is named sep (like separator).\par
\par
Look at the code in the editor, and run it.\par
\par
The sep argument delivers the following results:\par
\par
My-name-is-Monty-Python.\par
output\par
\par
The print() function now uses a dash, instead of a space, to separate the outputted arguments.\par
\par
Note: the sep argument's value may be an empty string, too. Try it for yourself.\par
\par
\par
he print() function - the keyword arguments\par
Both keyword arguments may be mixed in one invocation, just like here in the editor window.\par
\par
The example doesn't make much sense, but it visibly presents the interactions between end and sep.\par
\par
Can you predict the output?\par
\par
Run the code and see if it matches your predictions.\par
\par
Now that you understand the print() function, you're ready to consider how to store and process data in Python.\par
\par
Without print(), you wouldn't be able to see any results.\par
\par
Integers: octal and hexadecimal numbers\par
There are two additional conventions in Python that are unknown to the world of mathematics. The first allows us to use numbers in an octal representation.\par
\par
If an integer number is preceded by an 0O or 0o prefix (zero-o), it will be treated as an octal value. This means that the number must contain digits taken from the [0..7] range only.\par
\par
0o123 is an octal number with a (decimal) value equal to 83.\par
\par
The print() function does the conversion automatically. Try this:\par
\par
print(0o123)\par
\par
The second convention allows us to use hexadecimal numbers. Such numbers should be preceded by the prefix 0x or 0X (zero-x).\par
\par
0x123 is a hexadecimal number with a (decimal) value equal to 291. The print() function can manage these values too. Try this:\par
\par
print(0x123)\par
Coding floats\par
Let's see how this convention is used to record numbers that are very small (in the sense of their absolute value, which is close to zero).\par
\par
A physical constant called Planck's constant (and denoted as h), according to the textbooks, has the value of: 6.62607 x 10-34.\par
\par
If you would like to use it in a program, you should write it this way:\par
\par
6.62607E-34\par
\par
Note: the fact that you've chosen one of the possible forms of coding float values doesn't mean that Python will present it the same way.\par
\par
Python may sometimes choose different notation than you.\par
or example, let's say you've decided to use the following float literal:\par
\par
0.0000000000000000000001\par
\par
When you run this literal through Python:\par
\par
print(0.0000000000000000000001)\par
\par
this is the result:\par
\par
1e-22\par
output\par
\par
Python always chooses the more economical form of the number's presentation, and you should take this into consideration when creating literals.\par
\par
Key takeaways\par
1. Literals are notations for representing some fixed values in code. Python has various types of literals - for example, a literal can be a number (numeric literals, e.g., 123), or a string (string literals, e.g., "I am a literal.").\par
\par
2. The binary system is a system of numbers that employs 2 as the base. Therefore, a binary number is made up of 0s and 1s only, e.g., 1010 is 10 in decimal.\par
\par
Octal and hexadecimal numeration systems, similarly, employ 8 and 16 as their bases respectively. The hexadecimal system uses the decimal numbers and six extra letters.\par
3. Integers (or simply ints) are one of the numerical types supported by Python. They are numbers written without a fractional component, e.g., 256, or -1 (negative integers).\par
\par
4. Floating-point numbers (or simply floats) are another one of the numerical types supported by Python. They are numbers that contain (or are able to contain) a fractional component, e.g., 1.27.\par
\par
5. To encode an apostrophe or a quote inside a string you can either use the escape character, e.g., 'I\\'m happy.', or open and close the string using an opposite set of symbols to the ones you wish to encode, e.g., "I'm happy." to encode an apostrophe, and 'He said "Python", not "typhoon"' to encode a (double) quote.\par
\par
6. Boolean values are the two constant objects True and False used to represent truth values (in numeric contexts 1 is True, while 0 is False.\par
\par
EXTRA\par
\par
There is one more, special literal that is used in Python: the None literal. This literal is a so-called NoneType object, and it is used to represent the absence of a value. We'll tell you more about it soon.\par
rithmetic operators: exponentiation\par
A ** (double asterisk) sign is an exponentiation (power) operator. Its left argument is the base, its right, the exponent.\par
\par
Classical mathematics prefers notation with superscripts, just like this: 23. Pure text editors don't accept that, so Python uses ** instead, e.g., 2 ** 3.\par
\par
Take a look at our examples in the editor window.\par
\par
\par
Note: we've surrounded the double asterisks with spaces in our examples. It's not compulsory, but it improves the readability of the code.\par
\par
The examples show a very important feature of virtually all Python numerical operators.\par
\par
Run the code and look carefully at the results it produces. Can you see any regularity here?\par
\par
\par
Remember: It's possible to formulate the following rules based on this result:\par
\par
when both ** arguments are integers, the result is an integer, too;\par
when at least one ** argument is a float, the result is a float, too.\par
This is an important distinction to remember.\par
\par
\par
\par
\par
Arithmetic operators: integer division\par
A // (double slash) sign is an integer divisional operator. It differs from the standard / operator in two details:\par
\par
its result lacks the fractional part - it's absent (for integers), or is always equal to zero (for floats); this means that the results are always rounded;\par
it conforms to the integer vs. float rule.\par
Run the example below and see the results:\par
\par
print(6 // 3)\par
print(6 // 3.)\par
print(6. // 3)\par
print(6. // 3.)\par
\par
As you can see, integer by integer division gives an integer result. All other cases produce floats.\par
\par
\par
Let's do some more advanced tests.\par
\par
Look at the following snippet:\par
\par
print(6 // 4)\par
print(6. // 4)\par
\par
Imagine that we used / instead of // - could you predict the results?\par
\par
Yes, it would be 1.5 in both cases. That's clear.\par
\par
But what results should we expect with // division?\par
\par
Run the code and see for yourself.\par
\par
\par
What we get is two ones - one integer and one float.\par
\par
The result of integer division is always rounded to the nearest integer value that is less than the real (not rounded) result.\par
\par
This is very important: rounding always goes to the lesser integer.\par
\par
\par
Look at the code below and try to predict the results once again:\par
\par
print(-6 // 4)\par
print(6. // -4)\par
\par
Note: some of the values are negative. This will obviously affect the result. But how?\par
\par
The result is two negative twos. The real (not rounded) result is -1.5 in both cases. However, the results are the subjects of rounding. The rounding goes toward the lesser integer value, and the lesser integer value is -2, hence: -2 and -2.0.\par
\par
NOTE\par
\par
Integer division can also be called floor division. You will definitely come across this term in the future.\par
\par
\par
Shortcut operators\par
It's time for the next set of operators that make a developer's life easier.\par
\par
Very often, we want to use one and the same variable both to the right and left sides of the = operator.\par
\par
For example, if we need to calculate a series of successive values of powers of 2, we may use a piece like this:\par
\par
x = x * 2\par
\par
You may use an expression like this if you can't fall asleep and you're trying to deal with it using some good, old-fashioned methods:\par
\par
sheep = sheep + 1\par
\par
Python offers you a shortened way of writing operations like these, which can be coded as follows:\par
\par
x *= 2\par
sheep += 1\par
\par
Key takeaways\par
\par
1. A variable is a named location reserved to store values in the memory. A variable is created or initialized automatically when you assign a value to it for the first time. (2.1.4.1)\par
\par
2. Each variable must have a unique name - an identifier. A legal identifier name must be a non-empty sequence of characters, must begin with the underscore(_), or a letter, and it cannot be a Python keyword. The first character may be followed by underscores, letters, and digits. Identifiers in Python are case-sensitive. (2.1.4.1)\par
\par
3. Python is a dynamically-typed language, which means you don't need to declare variables in it. (2.1.4.3) To assign values to variables, you can use a simple assignment operator in the form of the equal (=) sign, i.e., var = 1.\par
\par
4. You can also use compound assignment operators (shortcut operators) to modify values assigned to variables, e.g., var += 1, or var /= 5 * 2. (2.1.4.8)\par
\par
5. You can assign new values to already existing variables using the assignment operator or one of the compound operators, e.g.: (2.1.4.5)\par
\par
var = 2\par
print(var)\par
\par
var = 3\par
print(var)\par
\par
var += 1\par
print(var)\par
\par
6. You can combine text and variables using the + operator, and use the print() function to output strings and variables, e.g.: (2.1.4.4)\par
\par
var = "007"\par
print("Agent " + var)\par
\par
you'd like to quickly comment or uncomment multiple lines of code, select the line(s) you wish to modify and use the following keyboard shortcut: CTRL + / (Windows) or CMD + / (Mac OS). It's a very useful trick, isn't it? Try this code in Sandbox.\par
\par
Key takeaways\par
\par
1. Comments can be used to leave additional information in code. They are omitted at runtime. The information left in source code is addressed to human readers. In Python, a comment is a piece of text that begins with #. The comment extends to the end of line.\par
\par
2. If you want to place a comment that spans several lines, you need to place # in front of them all. Moreover, you can use a comment to mark a piece of code that is not needed at the moment (see the last line of the snippet below), e.g.:\par
\par
# This program prints\par
# an introduction to the screen.\par
print("Hello!")  # Invoking the print() function\par
# print("I'm Python.")\par
\par
3. Whenever possible and justified, you should give self-commenting names to variables, e.g., if you're using two variables to store a length and width of something, the variable names length and width may be a better choice than myvar1 and myvar2.\par
\par
4. It's important to use comments to make programs easier to understand, and to use readable and meaningful variable names in code. However, it's equally important not to use variable names that are confusing, or leave comments that contain wrong or incorrect information!\par
\par
5. Comments can be important when you are reading your own code after some time (trust us, developers do forget what their own code does), and when others are reading your code (can help them understand what your programs do and how they do it more quickly).\par
The input() function\par
We're now going to introduce you to a completely new function, which seems to be a mirror reflection of the good old print() function.\par
\par
Why? Well, print() sends data to the console.\par
\par
The new function gets data from it.\par
\par
print() has no usable result. The meaning of the new function is to return a very usable result.\par
\par
The function is named input(). The name of the function says everything.\par
\par
The input() function is able to read data entered by the user and to return the same data to the running program.\par
\par
The program can manipulate the data, making the code truly interactive.\par
\par
Virtually all programs read and process data. A program which doesn't get a user's input is a deaf program.\par
\par
Take a look at our example:\par
\par
print("Tell me anything...")\par
anything = input()\par
print("Hmm...", anything, "... Really?")\par
\par
It shows a very simple case of using the input() function.\par
\par
Note:\par
\par
The program prompts the user to input some data from the console (most likely using a keyboard, although it is also possible to input data using voice or image);\par
the input() function is invoked without arguments (this is the simplest way of using the function); the function will switch the console to input mode; you'll see a blinking cursor, and you'll be able to input some keystrokes, finishing off by hitting the Enter key; all the inputted data will be sent to your program through the function's result;\par
note: you need to assign the result to a variable; this is crucial - missing out this step will cause the entered data to be lost;\par
then we use the print() function to output the data we get, with some additional remarks.\par
Try to run the code and let the function show you what it can do for you.\par
Key takeaways\par
\par
1. The print() function sends data to the console, while the input() function gets data from the console.\par
\par
2. The input() function comes with an optional parameter: the prompt string. It allows you to write a message before the user input, e.g.:\par
\par
name = input("Enter your name: ")\par
print("Hello, " + name + ". Nice to meet you!")\par
\par
3. When the input() function is called, the program's flow is stopped, the prompt symbol keeps blinking (it prompts the user to take action when the console is switched to input mode) until the user has entered an input and/or pressed the Enter key.\par
\par
NOTE\par
\par
You can test the functionality of the input() function in its full scope locally on your machine. For resource optimization reasons, we have limited the maximum program execution time in Edube to a few seconds. Go to Sandbox, copy-paste the above snippet, run the program, and do nothing - just wait a few seconds to see what happens. Your program should be stopped automatically after a short moment. Now open IDLE, and run the same program there - can you see the difference?\par
\par
Tip: the above-mentioned feature of the input() function can be used to prompt the user to end a program. Look at the code below:\par
\par
name = input("Enter your name: ")\par
print("Hello, " + name + ". Nice to meet you!")\par
\par
print("\\nPress Enter to end the program.")\par
input()\par
print("THE END.")\par
\par
3. The result of the input() function is a string. You can add strings to each other using the concatenation (+) operator. Check out this code:\par
\par
num1 = input("Enter the first number: ") # Enter 12\par
num2 = input("Enter the second number: ") # Enter 21\par
\par
print(num1 + num2) # the program returns 1221\par
\par
4. You can also multiply (* - replication) strings, e.g.:\par
\par
myInput = input("Enter something: ") # Example input: hello\par
print(myInput * 3) # Expected output: hellohellohello\par
Looping your code with for\par
Another kind of loop available in Python comes from the observation that sometimes it's more important to count the "turns" of the loop than to check the conditions.\par
\par
Imagine that a loop's body needs to be executed exactly one hundred times. If you would like to use the while loop to do it, it may look like this:\par
\par
i = 0\par
while i < 100:\par
    # do_something()\par
    i += 1\par
\par
It would be nice if somebody could do this boring counting for you. Is that possible?\par
\par
Of course it is - there's a special loop for these kinds of tasks, and it is named for.\par
\par
Actually, the for loop is designed to do more complicated tasks - it can "browse" large collections of data item by item. We'll show you how to do that soon, but right now we're going to present a simpler variant of its application.\par
\par
Take a look at the snippet:\par
\par
for i in range(100):\par
    # do_something()\par
    pass\par
\par
There are some new elements. Let us tell you about them:\par
\par
the for keyword opens the for loop; note - there's no condition after it; you don't have to think about conditions, as they're checked internally, without any intervention;\par
any variable after the for keyword is the control variable of the loop; it counts the loop's turns, and does it automatically;\par
the in keyword introduces a syntax element describing the range of possible values being assigned to the control variable;\par
the range() function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will feed the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the range() function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;\par
note the pass keyword inside the loop body - it does nothing at all; it's an empty instruction - we put it here because the for loop's syntax demands at least one instruction inside the body (by the way - if, elif, else and while express the same thing)\par
Our next examples will be a bit more modest in the number of loop repetitions.\par
\par
Estimated time\par
5 minutes\par
\par
Level of difficulty\par
Very easy\par
\par
Objectives\par
Familiarize the student with:\par
\par
using the for loop;\par
reflecting real-life situations in computer code.\par
Scenario\par
Do you know what Mississippi is? Well, it's the name of one of the states and rivers in the United States. The Mississippi River is about 2,340 miles long, which makes it the second longest river in the United States (the longest being the Missouri River). It's so long that a single drop of water needs 90 days to travel its entire length!\par
\par
The word Mississippi is also used for a slightly different purpose: to count mississippily.\par
\par
If you're not familiar with the phrase, we're here to explain to you what it means: it's used to count seconds.\par
\par
The idea behind it is that adding the word Mississippi to a number when counting seconds aloud makes them sound closer to clock-time, and therefore "one Mississippi, two Mississippi, three Mississippi" will take approximately an actual three seconds of time! It's often used by children playing hide-and-seek to make sure the seeker does an honest count.\par
\par
\par
Your task is very simple here: write a program that uses a for loop to "count mississippily" to five. Having counted to five, the program should print to the screen the final message "Ready or not, here I come!"\par
\par
Use the skeleton we've provided in the editor.\par
\par
EXTRA INFO\par
\par
Note that the code in the editor contains two elements which may not be fully clear to you at this moment: the import time statement, and the sleep() method. We're going to talk about them soon.\par
\par
For the time being, we'd just like you to know that we've imported the time module and used the sleep() method to suspend the execution of each subsequent print() function inside the for loop for one second, so that the message outputted to the console resembles an actual counting. Don't worry - you'll soon learn more about modules and methods.\par
\par
Expected output\par
1 Mississippi\par
2 Mississippi\par
3 Mississippi\par
4 Mississippi\par
5 Mississippi\par
Estimated time\par
5-10 minutes\par
\par
Level of difficulty\par
Easy\par
\par
Objectives\par
Familiarize the student with:\par
\par
using the continue statement in loops;\par
modifying and upgrading the existing code;\par
reflecting real-life situations in computer code.\par
Scenario\par
Your task here is even more special than before: you must redesign the (ugly) vowel eater from the previous lab (3.1.2.10) and create a better, upgraded (pretty) vowel eater! Write a program that uses:\par
\par
a for loop;\par
the concept of conditional execution (if-elif-else)\par
the continue statement.\par
Your program must:\par
\par
ask the user to enter a word;\par
use userWord = userWord.upper() to convert the word entered by the user to upper case; we'll talk about the so-called string methods and the upper() method very soon - don't worry;\par
use conditional execution and the continue statement to "eat" the following vowels A, E, I, O, U from the inputted word;\par
assign the uneaten letters to the wordWithoutVovels variable and print the variable to the screen.\par
Look at the code in the editor. We've created wordWithoutVovels and assigned an empty string to it. Use concatenation operation to ask Python to combine selected letters into a longer string during subsequent loop turns, and assign it to the wordWithoutVovels variable.\par
\par
Test your program with the data we've provided for you.\par
\par
\par
Test data\par
Sample input: Gregory\par
\par
Expected output:\par
\par
GRGRY\par
Sample input: abstemious\par
\par
Expected output:\par
\par
BSTMS\par
Sample input: IOUEA\par
\par
Key takeaways\par
\par
1. There are two types of loops in Python: while and for:\par
\par
the while loop executes a statement or a set of statements as long as a specified boolean condition is true, e.g.:\par
\par
# Example 1\par
while True:\par
    print("Stuck in an infinite loop.")\par
\par
# Example 2\par
counter = 5\par
while counter > 2:\par
    print(counter)\par
    counter -= 1\par
\par
the for loop executes a set of statements many times; it's used to iterate over a sequence (e.g., a list, a dictionary, a tuple, or a set - you will learn about them soon) or other objects that are iterable (e.g., strings). You can use the for loop to iterate over a sequence of numbers using the built-in range function. Look at the examples below:\par
\par
# Example 1\par
word = "Python"\par
for letter in word:\par
    print(letter, end="*")\par
\par
# Example 2\par
for i in range(1, 10):\par
    if i % 2 == 0:\par
        print(i)\par
\par
2. You can use the break and continue statements to change the flow of a loop:\par
\par
You use break to exit a loop, e.g.:\par
\par
text = "OpenEDG Python Institute"\par
for letter in text:\par
    if letter == "P":\par
        break\par
    print(letter, end="")\par
\par
You use continue to skip the current iteration, and continue with the next iteration, e.g.:\par
\par
text = "pyxpyxpyx"\par
for letter in text:\par
    if letter == "x":\par
        continue\par
    print(letter, end="")\par
\par
. The while and for loops can also have an else clause in Python. The else clause executes after the loop finishes its execution as long as it has not been terminated by break, e.g.:\par
\par
n = 0\par
\par
while n != 3:\par
    print(n)\par
    n += 1\par
else:\par
    print(n, "else")\par
\par
print()\par
\par
for i in range(0, 3):\par
    print(i)\par
else:\par
    print(i, "else")\par
\par
4. The range() function generates a sequence of numbers. It accepts integers and returns range objects. The syntax of range() looks as follows: range(start, stop, step), where:\par
\par
start is an optional parameter specifying the starting number of the sequence (0 by default)\par
stop is an optional parameter specifying the end of the sequence generated (it is not included),\par
and step is an optional parameter specifying the difference between the numbers in the sequence (1 by default.)\par
Example code:\par
\par
for i in range(3):\par
    print(i, end=" ") # outputs: 0 1 2\par
\par
for i in range(6, 1, -2):\par
    print(i, end=" ") # outputs: 6, 4, 2\par
\par
\par
\par
\par
\par
\par
Computer logic\par
Have you noticed that the conditions we've used so far have been very simple, not to say, quite primitive? The conditions we use in real life are much more complex. Let's look at this sentence:\par
\par
If we have some free time, and the weather is good, we will go for a walk.\par
\par
\par
We've used the conjunction and, which means that going for a walk depends on the simultaneous fulfilment of these two conditions. In the language of logic, such a connection of conditions is called a conjunction. And now another example:\par
\par
If you are in the mall or I am in the mall, one of us will buy a gift for Mom.\par
\par
\par
The appearance of the word or means that the purchase depends on at least one of these conditions. In logic, such a compound is called a disjunction.\par
\par
It's clear that Python must have operators to build conjunctions and disjunctions. Without them, the expressive power of the language would be substantially weakened. They're called logical operators.\par
\par
and\par
One logical conjunction operator in Python is the word and. It's a binary operator with a priority that is lower than the one expressed by the comparison operators. It allows us to code complex conditions without the use of parentheses like this one:\par
\par
counter > 0 and value == 100\par
\par
The result provided by the and operator can be determined on the basis of the truth table.\par
\par
If we consider the conjunction of A and B, the set of possible values of arguments and corresponding values of the conjunction looks as follows:\par
\par
\par
Argument A\tab Argument B\tab A and B\par
False\tab False\tab False\par
False\tab True\tab False\par
True\tab False\tab False\par
True\tab True\tab True\par
Computer logic\par
Have you noticed that the conditions we've used so far have been very simple, not to say, quite primitive? The conditions we use in real life are much more complex. Let's look at this sentence:\par
\par
If we have some free time, and the weather is good, we will go for a walk.\par
\par
\par
We've used the conjunction and, which means that going for a walk depends on the simultaneous fulfilment of these two conditions. In the language of logic, such a connection of conditions is called a conjunction. And now another example:\par
\par
If you are in the mall or I am in the mall, one of us will buy a gift for Mom.\par
\par
\par
The appearance of the word or means that the purchase depends on at least one of these conditions. In logic, such a compound is called a disjunction.\par
\par
It's clear that Python must have operators to build conjunctions and disjunctions. Without them, the expressive power of the language would be substantially weakened. They're called logical operators.\par
\par
and\par
One logical conjunction operator in Python is the word and. It's a binary operator with a priority that is lower than the one expressed by the comparison operators. It allows us to code complex conditions without the use of parentheses like this one:\par
\par
counter > 0 and value == 100\par
\par
The result provided by the and operator can be determined on the basis of the truth table.\par
\par
If we consider the conjunction of A and B, the set of possible values of arguments and corresponding values of the conjunction looks as follows:\par
\par
\par
Argument A\tab Argument B\tab A and B\par
False\tab False\tab False\par
False\tab True\tab False\par
True\tab False\tab False\par
True\tab True\tab True\par
\par
Key takeaways\par
\par
1. Python supports the following logical operators:\par
\par
and \f1\u8594?\f0  if both operands are true, the condition is true, e.g., (True and True) is True,\par
or \f1\u8594?\f0  if any of the operands are true, the condition is true, e.g., (True or False) is True,\par
not \f1\u8594?\f0  returns false if the result is true, and returns true if the result is false, e.g., not True is False.\par
2. You can use bitwise operators to manipulate single bits of data. The following sample data:\par
\par
x = 15, which is 0000 1111 in binary,\par
y = 16, which is 0001 0000 in binary.\par
will be used to illustrate the meaning of bitwise operators in Python. Analyze the examples below:\par
\par
& does a bitwise and, e.g., x & y = 0, which is 0000 0000 in binary,\par
| does a bitwise or, e.g., x | y = 31, which is 0001 1111 in binary,\par
\'98 does a bitwise not, e.g., \'98 x = 240, which is 1111 0000 in binary,\f2\par
^ does a bitwise xor, e.g., x ^ y = 31, which is 0001 1111 in binary,\par
>> does a bitwise right shift, e.g., y >> 1 = 8, which is 0000 1000 in binary,\par
<< does a bitwise left shift, e.g., y << 3 = , which is 1000 0000 in binary,\par
\par
\par
Why\f3  \f2 do\f3  \f2 we\f3  \f2 need\f3  \f2 lists\f3 ?\f2\par
It\f3  \f2 may\f3  \f2 happen\f3  \f2 that\f3  \f2 you\f3  \f2 have\f3  \f2 to\f3  \f2 read\f3 , \f2 store\f3 , \f2 process\f3 , \f2 and\f3  \f2 finally\f3 , \f2 print\f3  \f2 dozens\f3 , \f2 maybe\f3  \f2 hundreds\f3 , \f2 perhaps\f3  \f2 even\f3  \f2 thousands\f3  \f2 of\f3  \f2 numbers\f3 . \f2 What\f3  \f2 then\f3 ? \f2 Do\f3  \f2 you\f3  \f2 need\f3  \f2 to\f3  \f2 create\f3  \f2 a\f3  \f2 separate\f3  \f2 variable\f3  \f2 for\f3  \f2 each\f3  \f2 value\f3 ? \f2 Will\f3  \f2 you\f3  \f2 have\f3  \f2 to\f3  \f2 spend\f3  \f2 long\f3  \f2 hours\f3  \f2 writing\f3  \f2 statements\f3  \f2 like\f3  \f2 the\f3  \f2 one\f3  \f2 below\f3 ?\f2\par
\par
var1\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
var2\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
var3\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
var4\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
var5\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
var6\f3  = \f2 int\f3 (\f2 input\f3 ())\f2\par
\f3 :\f2\par
\f3 :\f2\par
\par
If\f3  \f2 you\f3  \f2 don't\f3  \f2 think\f3  \f2 that\f3  \f2 this\f3  \f2 is\f3  \f2 a\f3  \f2 complicated\f3  \f2 task\f3 , \f2 then\f3  \f2 take\f3  \f2 a\f3  \f2 piece\f3  \f2 of\f3  \f2 paper\f3  \f2 and\f3  \f2 write\f3  \f2 a\f3  \f2 program\f3  \f2 that\f3 :\f2\par
\par
reads\f3  \f2 five\f3  \f2 numbers\f3 ,\f2\par
prints\f3  \f2 them\f3  \f2 in\f3  \f2 order\f3  \f2 from\f3  \f2 the\f3  \f2 smallest\f3  \f2 to\f3  \f2 the\f3  \f2 largest\f3  (\f2 NB\f3 , \f2 this\f3  \f2 kind\f3  \f2 of\f3  \f2 processing\f3  \f2 is\f3  \f2 called\f3  \f2 sorting\f3 ).\f2\par
You\f3  \f2 should\f3  \f2 find\f3  \f2 that\f3  \f2 you\f3  \f2 don't\f3  \f2 even\f3  \f2 have\f3  \f2 enough\f3  \f2 paper\f3  \f2 to\f3  \f2 complete\f3  \f2 the\f3  \f2 task\f3 .\f2\par
\par
So\f3  \f2 far\f3 , \f2 you've\f3  \f2 learned\f3  \f2 how\f3  \f2 to\f3  \f2 declare\f3  \f2 variables\f3  \f2 that\f3  \f2 are\f3  \f2 able\f3  \f2 to\f3  \f2 store\f3  \f2 exactly\f3  \f2 one\f3  \f2 given\f3  \f2 value\f3  \f2 at\f3  \f2 a\f3  \f2 time\f3 . \f2 Such\f3  \f2 variables\f3  \f2 are\f3  \f2 sometimes\f3  \f2 called\f3  \f2 scalars\f3  \f2 by\f3  \f2 analogy\f3  \f2 with\f3  \f2 mathematics\f3 . \f2 All\f3  \f2 the\f3  \f2 variables\f3  \f2 you've\f3  \f2 used\f3  \f2 so\f3  \f2 far\f3  \f2 are\f3  \f2 actually\f3  \f2 scalars\f3 .\f2\par
\par
Think\f3  \f2 of\f3  \f2 how\f3  \f2 convenient\f3  \f2 it\f3  \f2 would\f3  \f2 be\f3  \f2 to\f3  \f2 declare\f3  \f2 a\f3  \f2 variable\f3  \f2 that\f3  \f2 could\f3  \f2 store\f3  \f2 more\f3  \f2 than\f3  \f2 one\f3  \f2 value\f3 . \f2 For\f3  \f2 example\f3 , \f2 a\f3  \f2 hundred\f3 , \f2 or\f3  \f2 a\f3  \f2 thousand\f3  \f2 or\f3  \f2 even\f3  \f2 ten\f3  \f2 thousand\f3 . \f2 It\f3  \f2 would\f3  \f2 still\f3  \f2 be\f3  \f2 one\f3  \f2 and\f3  \f2 the\f3  \f2 same\f3  \f2 variable\f3 , \f2 but\f3  \f2 very\f3  \f2 wide\f3  \f2 and\f3  \f2 capacious\f3 . \f2 Sounds\f3  \f2 appealing\f3 ? \f2 Perhaps\f3 , \f2 but\f3  \f2 how\f3  \f2 would\f3  \f2 it\f3  \f2 handle\f3  \f2 such\f3  \f2 a\f3  \f2 container\f3  \f2 full\f3  \f2 of\f3  \f2 different\f3  \f2 values\f3 ? \f2 How\f3  \f2 would\f3  \f2 it\f3  \f2 choose\f3  \f2 just\f3  \f2 the\f3  \f2 one\f3  \f2 you\f3  \f2 need\f3 ?\par
\par
What if you could just number them? And then say: give me the value number 2; assign the value number 15; increase the value number 10000.\par
\par
We'll show you how to declare such multi-value variables. We'll do this with the example we just suggested. We'll write a program that sorts a sequence of numbers. We won't be particularly ambitious - we'll assume that there are exactly five numbers.\par
\par
Let's create a variable called numbers; it's assigned with not just one number, but is filled with a list consisting of five values (note: the list starts with an open square bracket and ends with a closed square bracket; the space between the brackets is filled with five numbers separated by commas).\par
\par
numbers = [10, 5, 7, 2, 1]\par
\par
Let's say the same thing using adequate terminology: numbers is a list consisting of five values, all of them numbers. We can also say that this statement creates a list of length equal to five (as in there are five elements inside it).\par
\par
The elements inside a list may have different types. Some of them may be integers, others floats, and yet others may be lists.\par
\par
Python has adopted a convention stating that the elements in a list are always numbered starting from zero. This means that the item stored at the beginning of the list will have the number zero. Since there are five elements in our list, the last of them is assigned the number four. Don't forget this.\par
\par
You'll soon get used to it, and it'll become second nature.\par
\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent0{\pntxtb\'B7}}\fi-360\li720\ri-1710\sa200\sl276\slmult1\tx10260\tx10350 Before we go any further in our discussion, we have to state the following:\f0\lang9\par
{\pntext\f4\'B7\tab}\f3  our list is a collection of elements, but each element is a scalar\f0\par

\pard\ri-1710\sa200\sl276\slmult1\tx10260\tx10350\par
\f3\par
Negative indices are legal\par
It may look strange, but negative indices are legal, and can be very useful.\par
\par
An element with an index equal to -1 is the last one in the list.\par
\par
print(numbers[-1])\par
\par
The example snippet will output 1. Run the program and check.\par
Similarly, the element with an index equal to -2 is the one before last in the list.\par
\par
print(numbers[-2])\par
\par
The example snippet will output 2.\par
\par
The last accessible element in our list is numbers[-4] (the first one) - don't try to go any further!\par
\par
\f0\par
Functions vs. methods\par
A method is a specific kind of function - it behaves like a function and looks like a function, but differs in the way in which it acts, and in its invocation style.\par
\par
A function doesn't belong to any data - it gets data, it may create new data and it (generally) produces a result.\par
\par
A method does all these things, but is also able to change the state of a selected entity.\par
\par
A method is owned by the data it works for, while a function is owned by the whole code.\par
\par
\par
This also means that invoking a method requires some specification of the data from which the method is invoked.\par
\par
It may sound puzzling here, but we'll deal with it in depth when we delve into object-oriented programming.\par
\par
In general, a typical function invocation may look like this:\par
\par
result = function(arg)\par
\par
The function takes an argument, does something, and returns a result.\par
A typical method invocation usually looks like this:\par
\par
result = data.method(arg)\par
\par
Note: the name of the method is preceded by the name of the data which owns the method. Next, you add a dot, followed by the method name, and a pair of parenthesis enclosing the arguments.\par
\par
The method will behave like a function, but can do something more - it can change the internal state of the data from which it has been invoked.\par
\par
\par
\par
You may ask: why are we talking about methods, not about lists?\par
\par
This is an essential issue right now, as we're going to show you how to add new elements to an existing list. This can be done with methods owned by all the lists, not by functions.\par
ists in action\par
Let's leave lists aside for a short moment and look at one intriguing issue.\par
\par
Imagine that you need to rearrange the elements of a list, i.e., reverse the order of the elements: the first and the fifth as well as the second and fourth elements will be swapped. The third one will remain untouched.\par
\par
\par
Question: how can you swap the values of two variables?\par
\par
Take a look at the snippet:\par
\par
variable1 = 1\par
variable2 = 2\par
\par
variable2 = variable1\par
variable1 = variable2\par
\par
If you do something like this, you would lose the value previously stored in variable2. Changing the order of the assignments will not help. You need a third variable that serves as an auxiliary storage.\par
\par
This is how you can do it:\par
\par
variable1 = 1\par
variable2 = 2\par
\par
auxiliary = variable1\par
variable1 = variable2\par
variable2 = auxiliary\par
\par
Python offers a more convenient way of doing the swap - take a look:\par
\par
variable1 = 1\par
variable2 = 2\par
\par
variable1, variable2 = variable2, variable1\par
\par
Clear, effective and elegant - isn't it?\par
. to print and swap many numbers  , we do the following loop:\par
 for i in range(length // 2):\par
        mylist[i] , mylist[length - i -1] = mylist[length - i - 1], mylist[i]\par
\par
\par
\fs144 The inner life of lists (v imp)\fs22\par
Now we want to show you one important, and very surprising, feature of lists, which strongly distinguishes them from ordinary variables.\par
\par
We want you to memorize it - it may affect your future programs, and cause severe problems if forgotten or overlooked.\par
\par
Take a look at the snippet in the editor.\par
\par
The program:\par
\par
creates a one-element list named list1;\par
assigns it to a new list named list2;\par
changes the only element of list1;\par
prints out list2.\par
The surprising part is the fact that the program will output: [2], not [1], which seems to be the obvious solution.\par
\par
\par
Lists (and many other complex Python entities) are stored in different ways than ordinary (scalar) variables.\par
\par
You could say that:\par
\par
the name of an ordinary variable is the name of its content;\par
the name of a list is the name of a memory location where the list is stored.\par
Read these two lines once more - the difference is essential for understanding what we are going to talk about next.\par
\par
The assignment: list2 = list1 copies the name of the array, not its contents. In effect, the two names (list1 and list2) identify the same location in the computer memory. Modifying one of them affects the other, and vice versa.\par
\par
How do you cope with that?\par
\par
Three-dimensional arrays\par
Python does not limit the depth of list-in-list inclusion. Here you can see an example of a three-dimensional array:\par
\par
Imagine a hotel. It's a huge hotel consisting of three buildings, 15 floors each. There are 20 rooms on each floor. For this, you need an array which can collect and process information on the occupied/free rooms.\par
\par
First step - the type of the array's elements. In this case, a Boolean value (True/False) would fit.\par
\par
Step two - calm analysis of the situation. Summarize the available information: three buildings, 15 floors, 20 rooms.\par
\par
Now you can create the array:\par
\par
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]\par
\par
The first index (0 through 2) selects one of the buildings; the second (0 through 14) selects the floor, the third (0 through 19) selects the room number. All rooms are initially free.\par
\par
Now you can book a room for two newlyweds: in the second building, on the tenth floor, room 14:\par
\par
rooms[1][9][13] = True\par
\par
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]\par
\par
rooms =[[[False for r in range(20)] for f in range(15)] for t in range(3)\}\par
\par
[1][9][13] = True\par
\par
[0][4][1] = False\par
\par
vacancy = 0\par
\par
for roomNumber in range(20):\par
    if not rooms[2][14] [RoomNumber]:\par
        vacancy += 1\par
        \par
        \par
        vacancy = 0\par
        for roomnumber in range[20]:\par
            if not rooms[2][14] [Roomnumber]:\par
                vacancy  += 1\par
\par
t\par
\par
and release the second room on the fifth floor located in the first building:\par
\par
rooms[0][4][1] = False\par
\par
Check if there are any vacancies on the 15th floor of the third building:\par
vacancy = 0\par
\par
for roomNumber in range(20):\par
    if not rooms[2][14][roomNumber]:\par
        vacancy += 1\par
\par
The vacancy variable contains 0 if all the rooms are occupied, or the number of available rooms otherwise.\par
\par
\par
Congratulations! You've made it to the end of the module. Keep up the good work!\par
\par
to do cube of numbers from 1-5\par
cubed = [ number ** 3 range \par
\par
\par
cube = [ num ** 3 for num in range(1,9)]\par
print( cube )\par
Key takeaways\par
\par
1. You can pass information to functions by using parameters. Your functions can have as many parameters as you need.\par
\par
An example of a one-parameter function:\par
\par
def hi(name):\par
    print("Hi,", name)\par
\par
hi("Greg")\par
\par
An example of a two-parameter function:\par
\par
def hiAll(name1, name2):\par
    print("Hi,", name2)\par
    print("Hi,", name1)\par
\par
hiAll("Sebastian", "Konrad")\par
\par
An example of a three-parameter function:\par
\par
def address(street, city, postalCode):\par
    print("Your address is:", street, "St.,", city, postalCode)\par
\par
s = input("Street: ")\par
pC = input("Postal Code: ")\par
c = input("City: ")\par
\par
address(s, c, pC)\par
\par
2. You can pass arguments to a function using the following techniques:\par
\par
positional argument passing in which the order of arguments passed matters (Ex. 1),\par
keyword (named) argument passing in which the order of arguments passed doesn't matter (Ex. 2),\par
a mix of positional and keyword argument passing (Ex. 3).\par
Ex. 1\par
def subtra(a, b):\par
    print(a - b)\par
\par
subtra(5, 2)    # outputs: 3\par
subtra(2, 5)    # outputs: -3\par
\par
\par
Ex. 2\par
def subtra(a, b):\par
    print(a - b)\par
\par
subtra(a=5, b=2)    # outputs: 3\par
subtra(b=2, a=5)    # outputs: 3\par
\par
Ex. 3\par
def subtra(a, b):\par
    print(a - b)\par
\par
subtra(5, b=2)    # outputs: 3\par
subtra(5, 2)    # outputs: 3\par
\par
It's important to remember that positional arguments mustn't follow keyword arguments. That's why if you try to run the following snippet:\par
\par
def subtra(a, b):\par
    print(a - b)\par
\par
subtra(5, b=2)    # outputs: 3\par
subtra(a=5, 2)    # Syntax Error\par
\par
Python will not let you do it by signalling a SyntaxError.\par
. You can use the keyword argument passing technique to pre-define a value for a given argument:\par
\par
def name(firstN, lastN="Smith"):\par
    print(firstN, lastN)\par
\par
name("Andy")    # outputs: Andy Smith\par
name("Betty", "Johnson")    # outputs: Betty Johnson (the keyword argument replaced by "Johnson")\par
\par
\par
\par
Exercise 1\par
\par
What is the output of the following snippet?\par
\par
def intro(a="James Bond", b="Bond"):\par
    print("My name is", b + ".", a + ".")\par
\par
intro()\par
\par
Check\par
\par
Exercise 2\par
\par
What is the output of the following snippet?\par
\par
def intro(a="James Bond", b="Bond"):\par
    print("My name is", b + ".", a + ".")\par
\par
intro(b="Sean Connery")\par
\par
Check\par
My name is Sean Connery. James Bond.\par
\par
Exercise 3\par
\par
What is the output of the following snippet?\par
\par
def intro(a, b="Bond"):\par
    print("My name is", b + ".", a + ".")\par
\par
intro("Susan")\par
\par
Check\par
\par
Exercise 4\par
\par
What is the output of the following snippet?\par
\par
def sum(a, b=2, c):\par
    print(a + b + c)\par
\par
sum(a=1, c=3)\par
\par
Check\par
SyntaxError - a non-default argument (c) follows a default argument (b=2)\par
 few words about None\par
Let us introduce you to a very curious value (to be honest, a none value) named None.\par
\par
Its data doesn't represent any reasonable value - actually, it's not a value at all; hence, it mustn't take part in any expressions.\par
\par
For example, a snippet like this:\par
\par
print(None + 2)\par
\par
will cause a runtime error, described by the following diagnostic message:\par
\par
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\par
\par
Note: None is a keyword.\par
\par
There are only two kinds of circumstances when None can be safely used:\par
\par
when you assign it to a variable (or return it as a function's result)\par
when you compare it with a variable to diagnose its internal state.\par
Just like here:\par
\par
value = None\par
if value == None:\par
   print("Sorry, you don't carry any value")\par
\par
Don't forget this: if a function doesn't return a certain value using a return expression clause, it is assumed that it implicitly returns None.\par
\par
Let's test it.\par
Estimated time\par
10-15 minutes\par
\par
Level of difficulty\par
Easy\par
\par
Objectives\par
Familiarize the student with:\par
\par
projecting and writing parameterized functions;\par
utilizing the return statement;\par
testing the functions.\par
Scenario\par
Your task is to write and test a function which takes one argument (a year) and returns True if the year is a leap year, or False otherwise.\par
\par
The seed of the function is already sown in the skeleton code in the editor.\par
\par
Note: we've also prepared a short testing code, which you can use to test your function.\par
Best stBest study material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)Best study material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)Best study material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)Best study material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)udy material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)Best study material for CAT Data Interpretation & Logical Reasoning (DILR)\par
How to prepare for Data Interpretation for the CAT by Arun Sharma (Tata McGraw Hill)\par
How to prepare for Logical Reasoning for the CAT by Arun Sharma (Tata McGraw Hill)\par
The code uses two lists - one with the test data, and the other containing the expected results. The code will tell you if any of your results are invalid.\par
\par
\par
\par
\par
\par
\par
}
 